"""AaC Plugin implementation module for the report plugin."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by the aac gen-plugin, and it won't be overwritten if the file already exists.

from aac.plugins.plugin_execution import PluginExecutionResult, plugin_result
from aac.validate import validated_source
from aac.lang.active_context_lifecycle_manager import get_active_context
from aac.lang.definition_helpers import get_definitions_by_root_key
from aac.lang.definitions.definition import Definition
from aac.lang.definition_helpers import get_definitions_by_source_uri
from aac.lang.references import get_reference_target_value_from_structure
from aac.lang.language_context import is_definition_type, is_primitive_type

import yaml
import csv
import io
from typing import Optional, List, Dict

plugin_name = "report"


def report(report_definition_file: str, architecture_file: str, output_file: Optional[str] = None) -> PluginExecutionResult:
    """
    Generate YAML output from an Arch-as-Code report definition.

    Args:
        report_definition_file (str): The yaml file containing the report model.
        architecture_file (str): The yaml file containing the AaC model to interrogate.
        output_file (str): The file to write the generated YAML report. (Optional)
    """
    def _gen_yaml_report():
        ret_val = ""
        report_content_list = _generate_report(report_definition_file, architecture_file)
        for report in report_content_list:
            yaml_content = yaml.dump(report, default_flow_style=False)
            if len(ret_val) > 0:
                ret_val += "---\n"
            ret_val += yaml_content

        # TODO if output_file is provided, write ret_val to file.  Should we also provide content for cli output?
        if output_file is not None:
            print(f"print YAML to {output_file}")
        print(f"YAML = {yaml_content}")  # TODO delete this line
        return yaml_content

    with plugin_result(plugin_name, _gen_yaml_report) as result:
        return result


def report_csv(report_definition_file: str, architecture_file: str, output_file: Optional[str] = None) -> PluginExecutionResult:
    """
    Generate CSV output from an Arch-as-Code report definition.

    Args:
        report_definition_file (str): The yaml file containing the report model.
        architecture_file (str): The yaml file containing the AaC model to interrogate.
        output_file (str): The file to write the generated CSV report. (Optional)
    """
    def _gen_csv_report():
        ret_val = ""
        report_content_list = _generate_report(report_definition_file, architecture_file)
        for report in report_content_list:
            # convert report content to csv
            field_names = []
            for cont in report["data"]:
                for fn in cont:
                    field_names.append(fn)
            header_names = set(field_names)
            output = io.StringIO()
            writer = csv.DictWriter(output, fieldnames=header_names, delimiter=',')
            writer.writeheader()
            writer.writerows(report["data"])

            csv_report = output.getvalue()

            if len(ret_val) > 0:
                ret_val += "\n\n"
            ret_val += csv_report

        # TODO if output_file is provided, write ret_val to file.  Should we also provide content for cli output?
        if output_file is not None:
            print(f"print YAML to {output_file}")
        print(f"CSV = {ret_val}")  # TODO remove this line
        return ret_val

    with plugin_result(plugin_name, _gen_csv_report) as result:
        return result


def _get_report_field_content(definition: Definition, reference: str) -> str:
    return "nothing yet"


def _generate_report(report_file: str, architecture_file: str) -> dict:
    print(f"_generate_report processing {architecture_file}")

    report_defs = []
    report_results = []
    with validated_source(report_file) as report_result, validated_source(architecture_file) as arch_result:
        # get reports defined in the report file
        report_defs = get_definitions_by_root_key("report", get_definitions_by_source_uri(report_file, report_result.definitions))

        print(f"report_defs = {[entry.name for entry in report_defs]}")

        for report_def in report_defs:
            report_result = {}
            report_fields = report_def.get_top_level_fields()

            # get report result metadata
            report_result["title"] = report_fields["name"]
            report_result["description"] = report_fields["description"]

            # get data content
            content = []
            for arch_structure in _get_structures_and_replace_references(arch_result.definitions):
                data_result = {}
                for data_item in report_fields["data"]:
                    data_item_value = get_reference_target_value_from_structure(data_item["source"], arch_structure)
                    if len(data_item_value) == 0:
                        data_result[data_item["name"]] = ""
                    elif len(data_item_value) == 1:
                        data_result[data_item["name"]] = data_item_value[0]
                    else:
                        data_result[data_item["name"]] = data_item_value

                content.append(data_result)

            report_result["data"] = content

            report_results.append(report_result)

    return report_results


def _get_structures_and_replace_references(definitions: List[Definition]) -> List[Dict]:
    ret_val = []

    for definition in definitions:
        pass

    return ret_val


def _replace_references(structure_type: str, structure: dict) -> None:
    # TODO This relies on pass by reference and side effects persisting...need to confirm through test

    fields = get_active_context().get_definition_by_name(structure_type).get_top_level_fields()["fields"]
    print(f"top level fields for {structure_type} = {fields}")

    # loop through fields looking for complex types or reference primitives
    for field in fields:
        if is_primitive_type(field["type"]) and field["type"] == "reference":
            print("Found a reference")
        elif is_definition_type(field["type"]):
            type_name = field["type"]
            print(f"Found definition type {type_name}")


def _get_field_type(type_name: str, field_name: str) -> str:
    type_definition = get_active_context().get_definition_by_name(type_name)

    # ensure the type definition we got back is a schema
    if type_definition.get_root_key() != "schema":
        print(f"ERROR:  searched for type {type_name} and got a definition who's root wasn't schema")
        return None

    for schema_field in type_definition.structure["schema"]["fields"]:
        if schema_field["name"] == field_name:
            return schema_field["type"]
    # nothing found so return None
    return None
