"""AaC Plugin implementation module for the report plugin."""
# NOTE: It is safe to edit this file.
# This file is only initially generated by the aac gen-plugin, and it won't be overwritten if the file already exists.

from aac.plugins.plugin_execution import PluginExecutionResult, plugin_result
from aac.validate import validated_source
from aac.lang.definition_helpers import get_definitions_by_root_key
from aac.lang.definitions.definition import Definition
from aac.lang.definition_helpers import get_definitions_by_source_uri
from aac.lang.references import get_reference_target_value

import yaml
import csv
import io
from typing import Optional

plugin_name = "report"


def report(report_definition_file: str, architecture_file: str, output_file: Optional[str] = None) -> PluginExecutionResult:
    """
    Generate YAML output from an Arch-as-Code report definition.

    Args:
        report_definition_file (str): The yaml file containing the report model.
        architecture_file (str): The yaml file containing the AaC model to interrogate.
        output_file (str): The file to write the generated YAML report. (Optional)
    """
    def _gen_yaml_report():
        ret_val = ""
        report_content_list = _generate_report(report_definition_file, architecture_file)
        for report in report_content_list:
            yaml_content = yaml.dump(report, default_flow_style=False)
            if len(ret_val) > 0:
                ret_val += "---\n"
            ret_val += yaml_content

        # TODO if output_file is provided, write ret_val to file.  Should we also provide content for cli output?
        if output_file is not None:
            print(f"print YAML to {output_file}")
        print(f"YAML = {yaml_content}")  # TODO delete this line
        return yaml_content

    with plugin_result(plugin_name, _gen_yaml_report) as result:
        return result


def report_csv(report_definition_file: str, architecture_file: str, output_file: Optional[str] = None) -> PluginExecutionResult:
    """
    Generate CSV output from an Arch-as-Code report definition.

    Args:
        report_definition_file (str): The yaml file containing the report model.
        architecture_file (str): The yaml file containing the AaC model to interrogate.
        output_file (str): The file to write the generated CSV report. (Optional)
    """
    def _gen_csv_report():
        ret_val = ""
        report_content_list = _generate_report(report_definition_file, architecture_file)
        for report in report_content_list:
            # convert report content to csv
            field_names = []
            for cont in report["data"]:
                for fn in cont:
                    field_names.append(fn)
            header_names = set(field_names)
            output = io.StringIO()
            writer = csv.DictWriter(output, fieldnames=header_names, delimiter=',')
            writer.writeheader()
            writer.writerows(report["data"])

            csv_report = output.getvalue()

            if len(ret_val) > 0:
                ret_val += "\n\n"
            ret_val += csv_report

        # TODO if output_file is provided, write ret_val to file.  Should we also provide content for cli output?
        if output_file is not None:
            print(f"print YAML to {output_file}")
        print(f"CSV = {ret_val}")  # TODO remove this line
        return ret_val

    with plugin_result(plugin_name, _gen_csv_report) as result:
        return result


def _get_report_field_content(definition: Definition, reference: str) -> str:
    return "nothing yet"


def _generate_report(report_file: str, architecture_file: str) -> dict:
    print(f"_generate_report processing {architecture_file}")

    report_defs = []
    report_results = []
    with validated_source(report_file) as report_result, validated_source(architecture_file) as arch_result:
        # get reports defined in the report file
        report_defs = get_definitions_by_root_key("report", get_definitions_by_source_uri(report_file, report_result.definitions))

        print(f"report_defs = {[entry.name for entry in report_defs]}")

        for report_def in report_defs:
            report_result = {}
            report_fields = report_def.get_top_level_fields()

            # get report result metadata
            report_result["title"] = report_fields["name"]
            report_result["description"] = report_fields["description"]

            # get data content
            content = []
            for arch_definition in arch_result.definitions:
                data_result = {}
                for data_item in report_fields["data"]:
                    data_item_value = get_reference_target_value(data_item["source"], arch_definition)
                    if len(data_item_value) == 0:
                        data_result[data_item["name"]] = ""
                    elif len(data_item_value) == 1:
                        data_result[data_item["name"]] = data_item_value[0]
                    else:
                        data_result[data_item["name"]] = data_item_value

                content.append(data_result)

            report_result["data"] = content

            report_results.append(report_result)

    return report_results
